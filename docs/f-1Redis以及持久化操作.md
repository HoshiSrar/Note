# Redis

## 概述

* Redis 与传统数据库的一个主要区别在于，Redis 把所有数据都存储在内存中，而传统数据库通常只会把数据的索引存储在内存中，并将实际的数据存储在硬盘中。
* 为了满足不同的持久化需求，Redis 提供了 RDB 持久化、AOF 持久化和 RDB-AOF 混合持久化等多种持久化方式以供用户选择。如果用户有需要，也可以完全关闭持久化功能，让服务器处于无持久化状态。
* RDB 持久化是全量持久化，AOF 持久化是增量持久化

## 持久化方式

两种，RDB 和 AOF，以及两者的混合。

- RDB（Redis DataBase） 持久化
- AOF（append only file）持久化
- RDB-AOF 混合持久化
- 如果用户有需要，也可以完全关闭持久化功能，让服务器处于无持久化状态。

### 一、RDB持久化

#### 简介

- RDB 持久化是 Redis **默认使用**的持久化功能
- 该功能可以创建出一个经过**压缩的二进制文件**，其中包含了服务器在各个数据库中存储的键值对数据等信息。RDB持久化产生的文件都以 .rdb 后缀结尾，其中 rdb 代表 Redis Data Base（Redis数据库），默认的文件名是 dump.rdb。

#### 持久化命令

> **SAVE：阻塞服务器并创建RDB文件**
>
> - 用户可以通过在 Redis 控制台执行SAVE命令，要求 Redis 服务器以同步方式创建出一个记录了服务器当前所有数据库数据的RDB文件
>
> **BGSAVE：以非阻塞方式创建RDB文件**
>
> * Redis 提供了 SAVE 命令的异步版本 BGSAVE 命令：BGSAVE
> * 它与 SAVE 命令的不同之处在于，BGSAVE 不会直接使用 Redis 服务器进程创建 RDB 文件，而是使用子进程创建 RDB 文件。
> * 因为 BGSAVE 命令是以异步方式执行的，所以 Redis 服务器在 BGSAVE 命令执行期间仍然可以继续处理其他客户端发送的命令请求。

#### 通过配置选项自动创建 RDB 文件

- 通过在 Redis 的 redis.conf 配置文件中设置 save 选项，让 Redis 服务器在满足指定条件时自动执行 BGSAVE 命令

~~~ xml
save <seconds> <changes>     redis配置文件修改
~~~

- save 选项包括 seconds 和 changes 两个参数，简单来说，如果服务器在 seconds 秒之内，对其包含的各个数据库总共执行了至少 changes 次修改，那么服务器将自动执行一次 BGSAVE 命令。

#### 同时配置多个 save 选项

- Redis 允许用户同时向服务器设置多个 save 选项，当给定选项中的任意一个条件被满足时，服务器就会执行一次 BGSAVE

~~~ xml
save 6000 100
save 600 1000
save 60 10000
~~~

- 那么当以下任意一个条件被满足时，服务器就会执行一次 BGSAVE 命令：

  > - 在6000s（100min）之内，服务器对数据库执行了至少1次修改。
  > - 在600s（10min）之内，服务器对数据库执行了至少100次修改。
  > - 在60s（1min）之内，服务器对数据库执行了至少10000次修改。
  
#### Redis默认设置

* RDB 持久化是 Redis 默认使用的持久化方式，如果用户在启动 Redis 服务器时，既没有显式地关闭 RDB 持久化功能，也没有启用 AOF 持久化功能，那么Redis默认将使用以下 save 选项配置进行 RDB 持久化：

~~~ xml
save 60 10000
save 300 100
save 3600 1
~~~

#### SAVE 命令和 BGSAVE 命令的选择

* SAVE 命令在创建 RDB 文件期间会阻塞 Redis 服务器，所以如果我们需要在创建 RDB 文件的同时让 Redis 服务器继续为其他客户端服务，那么就只能使用 BGSAVE 命令来创建RDB文件。
* 因为 SAVE 命令无须创建子进程，它不会因为创建子进程而消耗额外的内存，所以在维护**离线的Redis服务器**时，使用 SAVE 命令能够比使用 BGSAVE 命令更快地完成创建 RDB 文件的工作。

#### 数据丢失

**SAVE 命令的停机情况**

SAVE命令是一个同步操作，它的开始和结束都位于同一个原子时间之内，所以如果用户使用 SAVE 命令进行持久化，那么服务器在停机时将丢失最后一次成功执行 SAVE 命令之后产生的所有数据。

**BGSAVE 命令的停机情况**

* 因为 BGSAVE 命令是一个异步命令，它的开始和结束并不位于同一个原子时间之内，所以如果用户使用 BGSAVE 命令进行持久化，那么服务器在停机时丢失的数据量将取决于最后一次成功执行的 BGSAVE 命令的开始时间。

#### 注意

* 注意，为了避免由于同时使用多个触发条件而导致服务器过于频繁地执行 BGSAVE 命令，Redis服务器在每次成功创建 RDB 文件之后，负责自动触发 BGSAVE 命令的时间计数器以及修改次数计数器都会被清零并重新开始计数：无论这个 RDB 文件是由自动触发的 BGSAVE 命令创建的，还是由用户执行的 SAVE 命令或 BGSAVE 命令创建的，都是如此。

#### ROF的缺点

* 无论用户使用的是 SAVE 命令还是 BGSAVE 命令，停机时服务器丢失的数据量将取决于创建 RDB 文件的时间间隔：间隔越长，停机时丢失的数据也就越多。
* RDB 持久化是一种全量持久化操作，它在创建 RDB 文件时需要存储整个服务器包含的所有数据，并因此会消耗大量计算资源和内存资源
* 用户如果想要保证服务器的性能处于合理水平，就不能过于频繁地创建 RDB 文件，这样一来，也就不可避免地会出现因为停机而丢失大量数据的情况

### 二、AOF持久化

#### 简介

* 服务器每次执行完写命令之后，都会以协议文本的方式将被执行的命令追加到 AOF 文件的末尾。这样一来，服务器在停机之后，只要重新执行 AOF 文件中保存的 Redis 命令，就可以将数据库恢复至停机之前的状态。

  ![](https://raw.githubusercontent.com/HoshiSrar/Note_Images/main/img/20231125052042.png)

* 可以看到，随着服务器不断地执行命令，被执行的命令也会不断地被保存到 AOF 文件中，这样一来，即使服务器在T4停机，它也可以在重启时通过重新执行 AOF 文件包含的命令来恢复数据。

#### 打开AOF持久化

* 用户可以通过在配置文件中设置 Redis 服务器的 appendonly 选项来决定是否打开 AOF 持久化功能

  ~~~xml
  appendonly <value> （value：yes/no）
  ~~~

#### 设置 AOF 文件的冲洗频率

* AOF 文件的冲洗机制将直接影响 AOF 持久化的安全性。为了消除上述机制带来的不确定性，Redis 配置文件中向用户提供了 appendfsync 选项，以此来控制系统冲洗 AOF 文件的频率

~~~xml
appendfsync <value> （value：always/everysec/no）
~~~

* appendfsync 的 value 有 always、everysec 和 no 3个值可选

  > - always — 每执行一个写命令，就对 AOF 文件执行一次冲洗操作。
  > - everysec — 每隔1s，就对 AOF 文件执行一次冲洗操作。
  > - no — 不主动对 AOF 文件执行冲洗操作，由操作系统决定何时对 AOF 进行冲洗。

#### AOF重写
> * 随着服务器不断运行，被执行的命令将变得越来越多，而负责记录这些命令的 AOF 文件也会变得越来越大。如果服务器曾经对相同的键执行过多次修改操作，那么 AOF 文件中还会出现多个冗余命令。
> * Redis 提供了 AOF 重写功能，该功能能够生成一个全新的 AOF 文件，并且文件中只包含恢复当前数据库所需的尽可能少的命令。
>   

* 用户可以通过执行 BGREWRITEAOF 命令或者设置相关的配置选

  项来触发AOF重写操作

  > * BGREWRITEAOF 命令
  > * AOF 重写配置选项

#### ROF的缺点

**优点**

* 与 RDB 持久化可能会丢失大量数据相比，AOF 持久化的安全性要高得多：通过使用 everysec 选项，用户可以将数据丢失的时间窗口限制在1s之内。

**缺点**

- 因为 AOF 文件存储的是协议文本，所以**它的体积会比包含相同数据、二进制格式的 RDB 文件要大得多**，并且生成 AOF 文件所需的时间也会比生成 RDB 文件所需的时间更长。
- 因为 RDB 持久化可以直接通过 RDB 文件恢复数据库数据，而 AOF 持久化则需要通过执行 AOF 文件中保存的命令来恢复数据库（前者是直接的数据恢复操作，而后者则是间接的数据恢复操作），所以 **RDB 持久化的数据恢复速度将比 AOF 持久化的数据恢复速度快得多**，并且数据库体积越大，这两者之间的差距就会越明显。
- 因为 AOF 重写使用的 BGREWRITEAOF 命令与 RDB 持久化使用的 BGSAVE 命令一样都需要创建子进程，所以在数据库体积较大的情况下，进行 AOF 文件重写将占用大量资源，并导致服务器被短暂地阻塞。

